---
title: Taro 使用原生模块
---

import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import { VueIcon, ReactIcon } from './guides/index'

Taro 支持使用小程序原生的**页面**、**组件**和**插件**。

#### 示例项目：

1. React：https://github.com/NervJS/taro-sample-weapp/tree/next
2. Vue：https://github.com/NervJS/taro-sample-weapp/tree/vue

> 注意：如果在 Taro 项目引用了小程序原生的页面、组件和插件，那么该项目将**不再具备多端转换的能力**。
> 例如，如果使用了微信小程序的原生组件，那么项目只能转换成微信小程序，转义成其他平台会失效，使用其他小程序原生组件同理。

## 使用原生组件

### 使用方法

#### 1. 在 app 或页面配置文件中配置 `usingComponents` 属性。

```js title="page.config.js"
export default {
  usingComponents: {
    // 定义需要引入的第三方组件
    // 1. key 值指定第三方组件名字，以小写开头
    // 2. value 值指定第三方组件 js 文件的相对路径
    'ec-canvas': '../../components/ec-canvas/ec-canvas'
  }
}
```

> 注意：Taro3 的组件是没有配置文件的，因此 usingComponents 必须配置在“页面”的配置文件中。

#### 2. 使用组件

<Tabs
  defaultValue="React"
  values={[
    {label:  <ReactIcon />, value: 'React'},
    {label: <VueIcon />, value: 'Vue'}
  ]}>
<TabItem value="React">

```jsx
import React, { Component } from 'react'
import { View } from '@tarojs/components'

export default class Index extends Component {
  this.state = {
    ec: {
      onInit: function () {}
    }
  }

  render () {
    return (
      <View>
        <ec-canvas id='mychart-dom-area' canvas-id='mychart-area' ec={this.state.ec} />
      </View>
    )
  }
}
```

</TabItem>

<TabItem value="Vue">

```html
<template>
  <view class='echarts'>
    <ec-canvas id='mychart-dom-area' canvas-id='mychart-area' :ec="ec"></ec-canvas>
  </view>
</template>

<script>
export default {
  data() {
    return {
      ec: {
        onInit: function () {}
      }
    }
  }
}
</script>
```

</TabItem>
</Tabs>

### 属性绑定

属性名和原生语法保持一致。

<Tabs
  defaultValue="React"
  values={[
    {label:  <ReactIcon />, value: 'React'},
    {label: <VueIcon />, value: 'Vue'}
  ]}>
<TabItem value="React">

```jsx
<van-button type='primary' loading loading-text='ing'>Button</van-button>
```

</TabItem>

<TabItem value="Vue">

```html
<van-button type='primary' :loading='true' loading-text='ing'>Button</van-button>
```

</TabItem>
</Tabs>

> 注意：在 Vue 中，如果组件的某些属性带有默认值 `true`，在 Taro 中使用时仍然需要**显式设置为 true**。

### 事件绑定

`React` 中需要以 `on` 开头（取代原生绑定语法中的 `bind`）的**驼峰形式**进行事件绑定。

`Vue` 的事件绑定与原生写法一致。

<Tabs
  defaultValue="React"
  values={[
    {label:  <ReactIcon />, value: 'React'},
    {label: <VueIcon />, value: 'Vue'}
  ]}>
<TabItem value="React">

```jsx
// 对应 bind:click 事件
<van-button type='primary' onClick={this.handleClick} >Button</van-button>
// 对应 bind:after-read 事件
<van-uploader fileList={[]} onAfterRead={this.onAfterRead} />
```

</TabItem>

<TabItem value="Vue">

```html
<!-- 对应 bind:click 事件 -->
<van-button type='primary' @click='handleClick'>Button</van-button>
<!-- 对应 bind:after-read 事件 -->
<van-uploader :fileList='[]' @after-read='onAfterRead' />
```

</TabItem>
</Tabs>

### 使用 Slot

`React` 中使用 `<Slot>` 组件实现。

`Vue` 中使用 `<slot-view>` 组件实现。

<Tabs
  defaultValue="React"
  values={[
    {label:  <ReactIcon />, value: 'React'},
    {label: <VueIcon />, value: 'Vue'}
  ]}>
<TabItem value="React">

```jsx
import React, { Component } from 'react'
import { View, Slot } from '@tarojs/components'

export default class Index extends Component {
  render () {
    return (
      <View>
        <van-calendar poppable show>
          <Slot name='title'>
            <View>Hello world</View>
          </Slot>
        </van-calendar>
      </View>
    )
  }
}
```

</TabItem>

<TabItem value="Vue">

```html
<template>
  <view>
    <van-calendar :poppable='true' :show='true'>
      <slot-view :name='"title"'>
        <view>Hello world</view>
      </slot-view>
    </van-calendar>
  </view>
</template>

<script>
export default {
  name: 'index'
}
</script>
```

</TabItem>
</Tabs>

### selectComponent

可以使用小程序页面实例的 `selectComponent` API 获取第三方原生组件的实例。

```js
import { getCurrentInstance } from '@tarojs/taro'

const { page } = getCurrentInstance()
page.selectComponent('#mychart-dom-area')
```

### 使用 vant-weapp

[详细文档](./vant)

## 使用原生页面

只需要在 app 配置中，设置好原生页面的路由即可。

```js title="app.config.js"
export default {
  pages: [
    'pages/native/native'
  ]
}
```

## 使用小程序插件

### 引入插件

使用插件前，使用者要在 `app.confg.js` 的配置中声明需要使用的插件，例如

```js title="app.config.js"
export default {
  plugins: {
    myPlugin: {
      version: '1.0.0',
      provider: 'wxidxxxxxxxxxxxxxxxx'
    }
  }
}
```

如上例所示， `plugins` 定义段中可以包含多个插件声明，每个插件声明以一个使用者自定义的插件引用名作为标识，并指明插件的 `appid` 和需要使用的版本号。其中，引用名（如上例中的 myPlugin）由使用者自定义，无需和插件开发者保持一致或与开发者协调。在后续的插件使用中，该引用名将被用于表示该插件。

### 使用插件组件

使用插件提供的自定义组件，和上述 “引入第三方组件” 的方式相仿，在页面或组件的配置中定义需要引入的自定义组件时，使用 `plugin://` 协议指明插件的引用名和自定义组件名，例如：

```js
export default {
  // 定义需要引入的插件
  usingComponents: {
    'hello-component': 'plugin://myPlugin/hello-component'
  }
}
```

出于对插件的保护，插件提供的自定义组件在使用上有一定的限制：

- 默认情况下，页面中的 `this.$scope.selectComponent` 接口无法获得插件的自定义组件实例对象；
- `Taro.createSelectorQuery` 等接口的 `>>>` 选择器无法选入插件内部。

### 使用插件页面

插件的页面从小程序基础库版本 2.1.0 开始支持。

需要跳转到插件页面时，url 使用 `plugin://` 前缀，形如 `plugin://PLUGIN_NAME//PLUGIN_PAGE`， 如：

```jsx
<Navigator url='plugin://myPlugin/hello-page'>
  Go to pages/hello-page!
</Navigator>
```

### 使用 js 接口

使用插件的 `js` 接口时，可以使用 `Taro.requirePlugin` 方法。例如，插件提供一个名为 `hello` 的方法和一个名为 `world` 的变量，则可以像下面这样调用：

```js
const myPluginInterface = requirePlugin('myPlugin')
const myWorld = myPluginInterface.world

myPluginInterface.hello()
```
