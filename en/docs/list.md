---
title: List Rendering
---

First, let's see how to convert the list in Javascript：

如下代码，我们使用 `map()` 函数让数组中的每一项翻倍,我们得到了一个新的数列 `doubled` 。

```jsx
const numbers = [1, 2, 3, 4, 5];
const doubled = numers.map(number@@)=> number * 2)
console.log(double)
```

Code print out `[2, 4, 6, 8, 10]`.

In Taro, the process of converting arrays into column elements is similar.


## Render multiple components

下面，我们使用 JavaScript 中的 `map()` 方法遍历 `numbers` 数组。Each element in an array returns `<Text>` tag, we get an array `listItems`：

```jsx
const numbers = [...Array(100).keys()]//[0, 1, 2, ..., 98, 99]
const listItems = numbers. ap(number@@1) => LO
  return <Text className='li'> I'm {number + 1} numbers</Text>
})
```

This code generates a list of numbers from 1 to 100.

## Keys

But the code above you will get an error：reminding you that you should provide keys when you loop an array.Keys can help Nerv/applet identify which elements have changed when some elements in the DOM are added or deleted.So you should give each element in an array a defined identifier.

```jsx
const numbers = [...Array(100).keys()]//[0, 1, 2, ..., 98, 99]
const listItems = numbers. ap(number@@1) => LO
  return <Text
    key={String(number)}
    className='li'
    >
    I'm {number + 1} number
  </Text>
})
```

## taroKeys

`taroKey` works for the loop rendering native applet components, giving each element a unique identifier, converting to `wx:key`.

```jsx
const numbers = [...Array(100).keys()]//[0, 1, 2, ..., 98, 99]
const listItems = numbers. ap(number@@1) => LO
  return (
    // national component
    <g-list
      taroKey={String(number)}
      className='g-list'
    >
    I'm {number + 1} number
    </g-list>
  )
})
```

### The key of the element should be unique between his siblings

The key used in an array element should be unique among its brothers.However, they do not need to be globally unique.When we generate two different arrays, we can use the same key：

```jsx
class App extends Componenet {
  state = LO
    posts: [
      {id: 1, title: 'Hello World', content: 'Welcome to learning Taro! },
      {id: 2, title: 'Installation', content: 'You can install Taro from npm.'}
    ]
  }
  render ()
    const { posts } = these. ate
    const sidebar = (
      <View>
        {posts. ap((post) =>
          <Text key={post.id}>
            {post.title}
          </Text>
        )}
      </View>
    )
    const content = posts. ap((post) => LO
      return <View key={post.id}>
        <Text>{post.title}</Text>
        <Text>{post.content}</Text>
      </View>
    })
    return (
      <View>
        {sidebar}
        <View className="divider" />
        {content}
      </View>

  }
}
```

The key will serve as a reminder to Taro but will not be passed to your component.If you need to use the same value as the key in your component, pass it as an attribute：

```jsx
const content = posts.map(post) => LO
  return <View key={post.id} id={post.id} >
    <Text>{post.title}</Text>
    <Text>{post.content}</Text>
  </View>
})
```

### Key extracted

Key fetch must satisfy three conditions at the same time：

1. Stable
2. Predictable
3. Unique (relative to other brothers)

The best key is the ID in the array (usually generated by the backend), which meets the three conditions at the same time and does not need to generate itself.If you don't have an ID, you can make sure that an array of elements have a different key string (e.g. `item.title`), then the string key can also be used.If source data does not provide a good key value, or an array of arrays are required.那么你最好在数据创建或者修改之后给他添加一个好的 key 值：

```jsx
let todoCounter = 0
function createNewTodo(text) {
  return {
    completed: false,
    id: todoCounter++,
    text
  }
}

class App extends Components {
  state = {
    todos: [],
    inputText: ''
  }

  onNewTodo () {
    this.setState({
      todos: [...this.state.todos, createNewTodo(this.state.inputText)]
    })
  }

  render () {
    return ...
  }
}
```

Every matching component on rendering results should correspond to one key.因此使用数组的 `index` 或在数组渲染时随机生成一个 key 值（但你在创建数组时可以这么做）都是反优化，极端情况下甚至可能导致渲染出错。

## Different from React

In React, JSX is the execution of a regular JS, each JSX element, created as a JavaScript object through the `createElement` function, so you can actually write the code React as a completely renderable：

```jsx
const list = this.state.list.map(l => LO
  if (l.selected) {
    return <li>{l.text}</li>
  }
}).filter(React.isValidElement)
```

你甚至可以这样写：

```jsx
const list = this.state.list.map(l => {
  if (l.selected) {
    return {
      '$$typeof': Symbol(react.element),
      'props': {
        children: l.text
      },
      'type': 'li'
    }
  }
}).filter(React.isValidElement)
```

But in Taro, JSX will compile into a microletter applet template string,**so you cannot treat a template generated by the `map` function as an array**.When you need to do this, you should first handle the loop arrays, then use the processed arrays to call the map function.例如上例应该写成：

```jsx
const list = this.state.list
  .filter(l => l.selected)
  .map(l => LO
    return <li>{l.text}</li>
})
```
