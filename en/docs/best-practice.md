---
title: Best practices
---

## Additional instructions on JSX support levels

As the writing in JSX is variable, we cannot support all JSX writings, and there are some JSX good uses that are temporarily not well supported due to microletter applets on the end of the program, please add to this the extent of JSX:

* [Cannot operate JSX array using methods other than Array#map](https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/manipulate-jsx-as-array.md)
* [Defining JSX](https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-jsx-in-class-method.md) for methods other than render() is not supported (supported from v1.3.0-beta.0)
* [Object extensions can not be used in JSX parameter](https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-spread-in-props.md) (from v1.3.0-beta.0, custom components can be expanded with object, built-in components still need to be imported, separately)
* [不支持无状态组件](https://github.com/NervJS/taro/blob/master/packages/eslint-plugin-taro/docs/no-stateless-function.md) (自 v1.3.0-beta.0 起支持)

The above rule has ESLint detected in the default template generated by Taro without any configuration.如果你的编辑器没有安装 ESLint 插件可以参考以下教程在你的编辑器安装：

* [VSCode](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
* [IntelliJ IDEA (WebStorm etBrains codes)](https://www.jetbrains.com/help/idea/eslint.html)
* [Sublime Text](https://packagecontrol.io/packages/ESLint)

By default, Taro compilers also warn about unrunning codes, which can be generated without calling stack information.If you need to disable ESLint check while compiling, you can add `ESLINT=false` parameters before command, eg:：

```bash
$ ESLINT=false taro build --type weapp - watch
```

## Best Encoding

After a longer period of exploration and validation, at the current time Taro is designed to implement the Taro component based on the original self-defined component system of the applet, so that the component of the current applet end is limited by the original component system of the applet, while in order to achieve the goal of code writing in React, Taro itself has done some codification and running handling, which also brings with it some interesting constraints, making it necessary to elaborate on best practices in the Taro code.

### Component Style Description

The format[custom component style](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)of the micromessage applet cannot be influenced by external style, for example by quoting a custom component in the page, and the style of writing a custom component directly into the page style is not effective.This is the same in Taro, and it is not the same as traditional web development that everyone knows.

### Set `defaultProps for component`

In custom components of the micromessaging applet, only attributes specified in `properties` can be imported from parent and received

```jsx
Component({
  properties: {
    myProperty: { // 属性名
      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）
      value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个
      observer: function (newVal, oldVal, changedPath) {
         // 属性被改变时执行的函数（可选），也可以写成在 methods 段中定义的方法名字符串, 如：'_propertyChange'
         // 通常 newVal 就是新设置的数据， oldVal 是旧数据
      }
    },
    myProperty2: String // 简化的定义方式
  }
  ...
})
```

And in Taro, the properties used in component code from `props` will be identified and added to the compiled `properties` temporarily supported

```jsx
this.props.property

const { property } = this.props

const property = this.props.property
```

But there are thousands of Harmlets in the hearts of a thousand people, and the code writing of different people is certainly different, so Taro compiles will certainly not cover all writings, while there may be cases in which a given attribute is not used but passed directly to a child component, which cannot be processed at the time of compilation. This will need to be addressed when you encoded to the component settings [`defaultProps`](./apis/about/tarocomponent.md#defaultprops)

Component set to `defaultProps` will be used when running to compensate for unprocessed instances of compilation. All properties are set to `properties` , set correctly `defaultProps` to avoid many exceptions.

### Component Passed Function Properties Beginning with `on`

> After v1.3.0-beta.0, the custom components can be passed around `on` but the built-in component event starts with `on` , we still recommend your event beginning with `on`.

In Taro, the parent component must start with `on` to pass a function to a child

```jsx
// Call Custom, incoming handleEvent function, Same called onTrigger
class Partes Extending Component {

  handleEvent () {

  }

  render (
    return (
      <Custom onTrigger={this.handleEvent}></Custom>
    )
  }
}
```

这是因为，微信小程序端组件化是不能直接传递函数类型给子组件的，在 Taro 中是借助组件的[事件机制](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)来实现这一特性，而小程序中传入事件的时候属性名写法为 `bindmyevent` 或者 `bind:myevent`

```xml
<!-- Call onMyEvent method when a myevent is triggered by a custom component -->
<component-tag-name bindmyevent="onMyEvent" />
<!-- or can write ->
<component-tag-name bind:myevent="onMyEvent" />
```

So the name of the function to pass the function in Taro starts with `on` and is consistent with the event bindings of the built-in component.

### The applet does not print incoming functions in the component

> No such limit from v1.3.0-beta.0

The rationale for the component inbound function of the applet is already mentioned, so don't print incoming functions in the applet, because results are not available, but `this.props.onXxx && this.props.onXxx() is fully supported` This determination whether or not this function is passed into to make calls is fully supported.

### Do not set the data used in the template to `undefined`

Since the applet does not support setting the value of any item in data to `undefined` please avoid doing so when setState.You can use null instead.

### Don't print in the component `this.props.children`

On the micromessage applet is delivered to a custom component via `<slot />` , while Taro uses `this.props.children` implemented this function when compiled, `this.props.children` will be compiled directly `<slot />` so it exists on the applet is synthetic sugar, don't print it in the component.

### Support props incoming JSX

> Support since `1.1.9`

Support props passing through JSX, but elements passing through JSX must start with `render`

For example, subcomponent prototype

```javascript
class Dialog extends Component
  render () LO
    return (
      <View className='dialog'>
        <View className='header'>
          {this.props.renderHeader}
        </View>
        <View className='body'>
          {this.props.children}
        </View>
        <View className='footer'>
          {this.props.renderFooter}
        </View>
      </View>
    )
  }
}
```

Parent call subcomponent is incoming JSX

```javascript
class App extends Component {
  render () {
    return (
      <View className='container'>
        <Dialog
          renderHeader={
            <View className='welcome-message'>Welcome!</View>
          }
          renderFooter={
            <Button className='close'>Close</Button>
          }
        >
          <View className="dialog-message">
            Thank you for using Taro.
          </View>
        </Dialog>
      </View>
    )
  }
}
```

### Component Properties Transfer Attention

Do not match `id`,`class`,`style` as the name of the properties and internal state of the custom component because these attributes are lost in the micromessage applet.

### Component `state` and question of renaming fields in `props`

Don't use fields with the same name on `state` and `props` , as these fields are attached to `data` in the microletter applet.

### The page lifetime of `component WillMount` does not match

This is because the page in the micromessage append is `onLoad` to get the routing parameter of the page, while all components before the page onLoad have been `attached`.因此页面的 `componentWillMount` 可能会与预期不太一致。e.g.：

```jsx
// Wrong prototype
runder () LO
  // cannot get routing parameters until illMount
  const abc = this.$router.params. bc
  return <Custom adc={abc} />
}

// Proof correctly
component WillMount ()
  const abc = these.$router.params.abc
  this.setState ({
    abc
  })
}
render () () () () ()
  // add a compatibility judgement
  return this. tate.abc && <Custom adc={abc} />
}
```

There is no effect on pages that do not need to wait until the WillMount to fetch routing parameters.

### 组件的 `constructor` 与 `render` 提前调用

很多细心的开发者应该已经注意到了，在 Taro 编译到小程序端后，组件的 `constructor` 与 `render` 默认会多调用一次，表现得与 React 不太一致。

这是因为，Taro 的组件编译后就是小程序的自定义组件，而小程序的自定义组件的初始化时是可以指定 `data` 来让组件拥有初始化数据的。开发者一般会在组件的 `constructor` 中设置一些初始化的 `state`，同时也可能会在 `render` 中处理 `state`  与 `props` 产生新的数据，在 Taro 中多出的这一次提前调用，就是为了收集组件的初始化数据，给自定义组件提前生成 `data` ，以保证组件初始化时能带有数据，让组件初次渲染正常。

所以，在编码时，需要在处理数据的时候做一些容错处理，这样可以避免在 `constructor` 与 `render` 提前调用时出现由于没有数据导致出错的情况。

### JS encoding must be a single quotation

In Taro, the JS code must write a single quote, especially in JSX, which may result in compilation errors if a double quotation occurs.

### Use of environment variables `process.env`

不要以解构的方式来获取通过 `env` 配置的 `process.env` 环境变量，请直接以完整书写的方式 `process.env.NODE_ENV` 来进行使用

```jsx
// 错误写法，不支持
const { NODE_ENV = 'development' } = process.env
if (NODE_ENV === 'development') {
  ...
}

// 正确写法
if (process.env.NODE_ENV === 'development') {

}
```

### Use `this.$componentType` to determine if the current Taro.Component is a page or component

`this.$componentType` may be taken as `PAGE` and `COMPONENT`, the developer may take different logic based on the value of this variable.

### Original applet component pass props to Taro component

**Taro v1.3+** has modified props systems so that native components are not compatible with properties passed through properties.

This can be done now by passing all props that need to pass into Taro components, using `extraProps`.

```js
// Widget general props pass
<plugin title="{{name}}" desc="{{desc}}" bindonclick="onClick"></plugin>

// The native applet component needs to be changed to the following forms when calling the Taro component：
this.setData(LO
  extraProps: {
    name,
    desc,
    onClick: this.onClick
  }
})
<plugin extraProps="{{extraProps}}" ></plugin>
```

## Global Variables

In Taro it is recommended to use `Redux` for managing global variables, but for some small apps, `Redux` it may appear to be more replaced, and this time you want to use global variables, it is recommended below.

Add a self-named `JS` file, e.g. `global_data.js`, example code below.

```jsx
const globalData = {}

export function set (key, val) {
  globalData[key] = val
}

export function get (key) {
  return globalData[key]
}
```

Then you can use it anywhere

```jsx
import { set as setGlobalData, get as getGlobalData } from './path/name/global_data'

setGlobalData('test', 1)

getGlobalData('test')
```
